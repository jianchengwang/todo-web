
<script>

// // 显示绑定
// // 通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。对于被调用的函数来说，叫做间接调用

// var a = 0;
// function foo(){
//     console.log(this.a);
// }
// var obj = {
//     a:2
// };
// foo();//0
// foo.call(obj);//2

// // 普通绑定无法解决隐式丢失问题
// var a = 0;
// function foo(){
//     console.log(this.a);
// }
// var obj1 = {
//     a:1
// };
// var obj2 = {
//     a:2
// };
// foo.call(obj1);//1
// foo.call(obj2);//2

// // 硬绑定，使this不能更改
// var a = 0;
// function foo(){
//     console.log(this.a);
// }
// var obj = {
//     a:2
// };
// var bar= function(){
//     foo.call(obj);
// }
// //在bar函数内部手动调用foo.call(obj)。因此，无论之后如何调用函数bar，它总会手动在obj上调用foo
// bar();//2
// setTimeout(bar,100);//2
// bar.call(window);//2

// api
var id = 'window';
function foo(el){
    console.log(el,this.id);
}
var obj = {
    id: 'fn'
};
[1,2,3].forEach(foo);//1 "window" 2 "window" 3 "window"
[1,2,3].forEach(foo,obj);//1 "fn" 2 "fn" 3 "fn"

</script>